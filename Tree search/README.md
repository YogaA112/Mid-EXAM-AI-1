# 练习
```
本仓库只为自己练习使用，无任何其他用途
```
## 查找
### 二分查找
```
二分查找根号n还不错
这个地方需要注意一点，就是最好设置一个n，每次n = n*2.0
如果大了，那就old_item - old_item/n
如果小了，那就old_item + old_item/n
慢慢的缩小距离

另外精度需要考虑一定的位数，就可以通过保留上次计算的结果，如果和上次一样，那么就可以退出了，如果不同，那么就可以赋值给这个保留计算结果的变量
```
### 海量数据查找重复
#### hash
```
将数据先预处理做一次hash，然后再进行查找重复的
```

#### bitmap
```
这个还不太懂
今天看了一下，应该是通过取最高的前两位的数字，因为11 > 10 > 01 > 00
所以就分为4个部分
然后在这个过程中，再进行新一轮的11 10 01 00这样的分散下去
```
### 海量数据查找中位数
#### 分桶
```
将数字按照最高位的00 01 10 11位分别装到不同的桶中
这个过程中对桶中的数据进行统计数量

计算中位数落到哪个桶中，对这个桶进行一次XX00 XX01 XX10 XX11再进行划分
然后再进行计算中位数，直到这个桶中查找出中位数

```

#### 查找最长的字串
```
定义head_index tail_index，max_length
然后先做一个临时的temp_array，如果未重复，就将这个串append到列表中，如果重复了，那么就从最开始的重复字串处给锯断，在这个过程中判断temp_array是否超过了max_length，如果超过，记录head_index和tail_index，结束后返回
需要注意的是array.index(item)拿到的是第一个字串的结果，而不是最后一个，所以要自己设置一个index，每次循环自增1

另外注意切片的时候需要temp_string = temp_string[index+1:] 记得加1！！！
另外记得max_length需要变化
```
## 合并
#### 两个数组合并
```
可以设置两个指针，第一个指针的对应的值大于第二个指针对应的值,则第二个指针往后走
如果两个指针对应的值相同的话，那么就输出，这两个指针都向前走
如果第一个指针对应的值小于第二个指针对应的值，那么第一个指针则往后走

这样整个下来之后时间复杂度应该是O(min(m,n))，以两个列表最少的数量的遍历就可以获得交集
```

## 排序
### 堆排序
```
堆排序中比较重要的一点是从最后一个非叶子节点开始往前，一般是index = n/2-1
然后需要注意的是，排序完一次后需要头尾互相换，这里的尾巴一定一定是新的tail，而不是老的tail!!!
```
### 快排
```
主要的问题是选取最后一个节点为base，从前往后扫描，遇到比"base"大的数值，那么就把这个数值将最后一个数值覆盖掉，然后循环结束break
然后再从后往前扫描，遇到比"base"小的值，将前面的index对应的值覆盖掉
当head 和tail相交时候，将base填进去
前面两个是两个循环，因为要来回扫描多遍，所以还需要一个head < tail的判断来进行死循环


然后，分成前后两个数组，再次重复上述的动作，也就是需要递归

那，什么时候停止递归呢？就是当head == tail的时候, 也就是传递进去的头尾是一样的时候就停止了


特别注意：两层while循环，一定记得，不然只有一层
          另外需要注意head_index _head_index _tail_index tail_index的大小关系

```
### 归并排序

```
将大的列表拆成小的队列，比方说拆成4和以下的队列
然后小于4的队列直接进行快排，return 跳出递归
大于4的队列再次调用自己进行拆分
拆分完的两个队列进行排序

那就有三个功能：拆分小队列， 子队列排序，两个队列排序

```

### topk问题
```
可以使用python中的特殊技能：分片来实现插入时候造成的数据过多
比如说可以通过array = array[:k]这样来实现
```
### 第k大的问题

```
可以通过快速排序的思维，选择一个base_item 然后将base_item中的数进行查找
如果base_item的index是大于数组长度的2分之1，那么就在后面的组里面查找
如果base_item的index是小于数组长度的2分之1，那么就在前面的组里面查找
```


## 队列的实现
```
这里的话队列的实现在python中可以使用array.insert(0, item)来实现先进先出的功能
```
## 栈的实现
```
可以通过使用array.append(item), array.pop() 来实现栈

```

## 二叉树的实现
```
可以使用class来定义biTree，biTree中可以有两个.left和.right初始化为None
然后在遍历的时候就可以判断是不是None，来判断是否分支走到了尽头
```

## 一些shell工具使用python实现
### tail -n 命令实现
```
思想就是使用open 文件后的f.seek(i, 2)，通过变化i然后再判断f.readlines()的数组的个数，如果数组的个数是大于n的，那么就输出最后n个[-n:]
如果数组的个数是小于n的，那么可以通过对i指数增长，或者乘数增长来进行输出到数组，然后再seek到合适的位置
现在实现的还没有判断全部文件的长度，现在如果n大于全部的文件行数，会报错
```

## 链表翻转
```
使用栈，最后弹出的是最早弹出的对象的前驱
需要注意边界条件，不然就死循环了，内部形成环了

另外一个就是p temp q，刚开始初始化p的时候需要将p的next给设置为None，不然就会出问题

```
